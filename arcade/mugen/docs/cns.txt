The CNS format
==============
M.U.G.E.N, Elecbyte (c)1999

Beta-release documentation (incomplete)
Updated 16 Aug 99


Contents
--------
Section I.    Introduction
Section II.   Player Variables
Section III.  States
Appendix A.   State Trigger Index
Appendix B.   State Controller Index
Appendix C.   Special State Controller Numbers


============================================================
I. Introduction
============================================================

The CNS file of a player serves two purposes:
i. It defines the variables of that player, such as walking speed, 
drawing scale factor, and so on.
ii. It contains the states of the player, which describe all the moves 
that the player can do. States are the building blocks that you can use 
to create simple as well as complicated moves.

Like many other character files, the CNS is a text file that you can 
edit with any text editor. 

In the CNS file, a semicolon (;) is considered a "comment" character. 
Any text on the same line after the semicolon will be ignored by the 
program. The CNS is mostly case-insensitive, i.e. "MyName" is treated 
the same as "myname" and "mYnAMe". The only exception is the "command" 
state controller, but you do not need to worry about this for now.

Some terminology
----------------
When we say "group", we mean any block of lines of text beginning with 
something that looks like [groupname], and ending before the next 
group. For example, the group "Blah" consists of the first three lines 
in the following:

[Blah]
line1
line2
[Group 2]
more lines

Within a group, the order of parameters can appear in any order. So,

[SomeGroup]
value1 = 1234
value2 = A string

is equivalent to:

[SomeGroup]
value2 = A string
value1 = 1234



============================================================
II. Player Variables
============================================================

No full documentation yet. See chars/kfm/kfm.cns for comments on each 
variable.

Some importants one to note:
- In [Size], you can use "xscale" and "yscale" to change the width and 
height of your character. This saves the trouble of scaling every 
single one of the sprites. 
- Set up the speeds of the player in [Velocity]
- Set the player's downward acceleration -- "yaccel" in [Movement]



============================================================
III. States
============================================================

a. Introduction to States
b. Basic Parts of a State
c. Details on StateDef
d. Details on State Controllers
e. Common states (common1.cns)


-----------------------------
III.a. Introduction to States
-----------------------------
Programming states is the hardest part of creating a character. It 
entails a lot of work, testing, and sometimes trial-and-error. In this 
section, well often refer the player being programmed, and to his 
opponent as well. Let us call the player whose states we are editing 
P1, and his opponent P2.

Do not be discouraged if you do not understand a lot of this document 
on your first reading. The best way to learn about states is to first 
play around with values in the CNS of a completed character, and see 
what effects they have on him or her. There's nothing to fear from 
"tweaking" the CNS; M.U.G.E.N is designed to detect syntax errors and 
report them.

Included with the M.U.G.E.N distribution package is a character named 
Kung Fu Man (KFM for short.) You can find him in the directory 
chars/kfm.

How you enter a state is programmed in the CMD file. See the CMD 
document for more information.

Here are some concepts that will be useful for you to know:
1. Life and power
2. Control
3. Game-time and state-time
4. Position, velocity and acceleration
5. Juggling

1. Life and power
A player's life bar is the yellow bar at the top of the screen on 
his side of the screen. When the life bar reaches zero, the player 
is knocked out. His power bar is the blue bar, and that increases 
with each attack he gives or takes. When the power bar reaches 
certain values, he can do super moves.

2. Control
When we say a player "has control", we mean that he is ready to walk 
or jump or attack. A player who does not have control will not 
respond to your input (from keyboard or joystick). For example, when 
P1 is in his stand state, he has control, and will walk forward if 
you press the forward button. A player will typically not have 
control when he is in an attack state, otherwise you could just walk 
away halfway through a punch.

There is an exception to the rule, however. Sometims you can let the 
player respond to certain moves even if he has no control. That is 
called a "move interrupt", or a "move cancel". See the CMD 
documentation for details.

We will frequently refer to a player's "control flag". A "flag" is a 
value that is either true, or false. If we say the player's control 
flag is true, then it means he has control.

3. Game-time and state-time
M.U.G.E.N keeps track of the time that has passed in the game. Every 
time the game is updated (this includes updating the players, 
checking collisions, and drawing to the screen), we say game-time 
has increased by one.
The time a player has spent in a state is known as the "state-time". 
The state-time starts at 0 at the beginning of a state, and 
increases by one tick for every tick of game-time.

4. Position, velocity and acceleration
Those of you with basic knowledge of math should understand these 
concepts. M.U.G.E.N uses the following coordinate system.
The greater the X-position, the farther right the player is. The 
less the X-position, the closer he is to the left.
A Y-position of zero is at ground level. As the player's Y-position 
gets larger he moves downwards. For example, a negative Y-position 
means he is in the air.
Similarly, when we say a player has positive X-velocity, it means he 
is moving forward, and if he as negative X-velocity, he is moving 
backwards. A player with positive Y-velocity is moving downward, and 
a negative Y-velocity means he is moving up.
A positive X-acceleration means the player's X-velocity is 
increasing, a negative X-acceleration means his X-velocity is 
decreasing. Likewise for Y-acceleration.

5. Juggling
M.U.G.E.N allows for certain moves to "juggle", that is, to hit 
opponents who have been knocked into the air, or are lying down on 
the ground. The juggling system works this way: each person starts 
with a set number of juggle "points" on the first hit that makes 
them fall, typically 15.
Some quick terminology: when we say a player is "falling", then we 
mean he does not recover control in the air, and will fall onto the 
ground.
If a player is hit while he is in the falling in the air or lying 
down on the ground, then his juggle points will decrease by an 
amount depending on the attack. When an attack requires more juggle 
points than the opponent has left, then the attack will miss. Any 
move that causes the opponent to fall immediately subtracts its 
juggle points on the first hit.
For example, an attack that requires 5 juggle points could 
theoretically be used to juggle the opponent twice, leaving the 
opponent with 1 point left. Subsequent such attacks will miss.
The reason for this juggle system is to prevent infinite combos in 
the air.


-----------------------------
III.b. Basic Parts of a State
-----------------------------

Note: This section assumes you have at least browsed the documentation 
of AIR files, and understand the concepts of animation, as know the 
meaning of key words and phrases such as action and element of an 
action.

Here is a short example state for P1:

[Statedef 200]
type = S
physics = S
movetype = I
ctrl = 0
anim = 200
velset = 0

[State 200, 1]
type = ChangeState
trigger1 = AnimTime = 0
value = 0
ctrl = 1

This state plays back the Action 200 of P1s animation, and returns P1 
to his standing state after the animation has ended. In this case, 
assume Action 200 has a finite looptime. That is, Action 200 does not 
have any elements with time equal to -1.

At this point, you do not need to worry about the details. Let us begin 
by knowing what a state consists of.

All states must have a single Statedef section and one or more State 
sections. 

Statedef contains the starting information of a state, such as what 
kind of state it is (standing, crouching, in the air) and what kind of 
move he is doing (attacking, idling.) 

Each State section is referred to as a state controller, or a 
controller for short. Controllers tell the program what to do to P1, 
and when to do it. There are many kinds of controllers, each with its 
own function. For example, there are controllers to change the players 
position or velocity, define the effects of attacks, create 
projectiles, switch between animation Actions, change states, and so 
on. Each controller must have at least one trigger. A trigger is an 
event that causes the controller to be activated. Examples are: trigger 
at the start of the state, trigger at the end of the animation (as seen 
in the example State above), trigger on an element of an animation 
Action, trigger when P2 is within a certain range of P1, and so on.


--------------------------
III.c. Details on StateDef
--------------------------

Every state must begin with exactly one StateDef group, also known as a 
Statedef section. A StateDef group must look like this (put in one or 
more parameters where the dots are):
[Statedef state_number]
. state_parameters
.
.
Replace state_number with the number of the state you are programming. 
With the exception of the special group numbers (see Appendix C) you 
are allowed to use any state number you choose. 

The lines that follow should include the following parameters:
1. type
2. movetype
3. physics
4. anim

1. type
This is the state type of P1 in that state. It defines if he is 
standing, crouching, in the air, or lying down. The corresponding 
values are "S", "C" , "A" and "L" respectively (without the 
quotation marks). If this line is omitted, it assumes the type is 
"S". You will most commonly use "S", "C" and "A". For example, a 
crouching state type would require the line:

type = C

The type is used to determine several factors, most importantly, how 
P1 will react to being hit. For example, being in a "stand"-type 
state, P1 will react as if he is standing on the ground. If the type 
was "air", then P1 would react to the hit accordingly.

2. movetype
This is the type of move P1 is doing: "A" for attack, "I" for idle 
and "H" for being hit. The value is assumed to be "I" if this line 
is omitted. "A" and "H" should be self-explanatory. "I" is used for 
states where P1 is neither attacking, nor being hit. For example, an 
attack state should have the line:

movetype = A

You need to specify the movetype so the program will know how to 
process the state. Incorrectly specifying the movetype may cause P1 
to act incorrectly.

3. physics
You need to specify what physics to use in that state. Valid values 
are "S" for stand, "C" for crouch, "A" for air, and "N" for none. If 
omitted, the value of "N" is assumed. The kind of physics is used to 
determine how P1 behaves.

For "S" physics, P1 will experience friction with the ground. The 
value for the friction coefficient is set in the Player Variables 
(see section II).
For "C" physics, P1 will experience friction, just like in the "S" 
state.
For "A" physics, P1 will accelerate downwards, and if his Y-position 
is greater than 0 (ie. he touches the ground) he will immediately go 
into his landing state.
If you use "N" P1 will not use any of these pre-programmed physics.

Do not confuse "physics" with the state "type". They are usually the 
same, but you are given the choice if you want more control. 

4. anim
This parameter changes the Animation Action of P1. Specify the 
action number as the value. If you do not want P1 to change 
animation at the start of the state, omit this parameter.

So to have a state with number 400, where the player is doing a 
crouching attack with Action 400, the typical parameters would be:

[Statedef 400]
type = c
movetype = a
physics = c
anim = 400


The other optional parameters that you can use are:
4. velset
5. ctrl
6. poweradd
7. juggle

4. velset
You can use velset to set P1's velocity at the beginning of the 
state. The format is a number pair, representing the x velocity and 
the y velocity respectively. Omitting this line will leave P1's 
velocity unchanged. For example, 
velset = 4,-8
makes P1 start moving diagonally up and forwards.
There is an exception to this. Even if you have velset = 0, 
attacking P2 in the corner will push P1 away.

5. ctrl
This parameter will set P1's control. A value of "0" sets the flag 
to false, "1" sets it to true. If omitted, P1's control flag is left 
unchanged. For example, to give P1 control, use
ctrl = 1

6. poweradd
When included, the poweradd parameter adds to the player's power 
bar. The value is a number, and can be positive or negative. This 
parameter is typically used in attack moves, where you want the 
player to gain power just by performing the attack. For example, to 
add 40 power, type
poweradd = 40

7. juggle
The juggle parameter is useful only for attacks. It specifies how 
many points of juggling the move requires. If omitted for an attack, 
that attack will juggle if the previous attacking state successfully 
juggled. You should include the juggle parameter for all attacks. If 
an attack spans more than one state, include the juggle parameter 
only in the first state of that attack. Juggling was explained in 
detail in "Useful Concepts" in Section IIIa.


-----------------------------------
III.d. Details on State Controllers
-----------------------------------

d.1 Controller Format
d.2 Triggers
d.3 Commonly-used controllers


III.d.1 Controller Format
-------------------------
All states must have at least one state controller, otherwise it will 
cause an error. State controller groups have the following format:
[State state_number, some_number]
type = controller_type
trigger1 = trigger_type
.  additional parameters depending on controller
.
.

The state_number must be the same number of the state from the 
statedef. some_number can be any number you choose; it is the number 
that is reported when an error is found, so you know which controller 
needs to be fixed. 

The controller_type is the name of the controller you are using. Each 
type of controller has a different effect, and requires different 
parameters. See Appendix B for a full list of state controllers.

The order of the controllers is significant. Controllers listed first 
are the ones checked and, if necessary, activated first.

Here is an example of a controller that gives P1 control at the start 
of the state (the same effect as putting "ctrl = 1" as a parameter in 
the StateDef):

[State 300, 1] ;State 300. 1 is just an arbitrary number.
type = CtrlSet ;Changes the control flag.
trigger1 = Time = 0
value = 1

In this example, the CtrlSet type lets you change the control flag of 
P1. The line that reads "trigger1 = Time = 0" means that this 
controller is activated when the state-time is 0, ie. at the start of 
that state. The line "value = 1" says that we want to set the value of 
the control flag to 1, which means true. If we want to make P1 start 
the state with no control, then we just need to change the last line to 
"value = 0".

Let's look another example. This controller moves P1 forwards by 10 
pixels twice: on the second and third element of his current Animation 
Action. Don't worry if you don't know what parameters go with which 
controller types. You can learn more about them from Appendix B.

[State 300, 2]
type = PosAdd ;Adds to P1's position
trigger1 = AnimElem = 2 ;Trigger on 2nd element.
trigger2 = AnimElem = 3 ;Trigger on 3rd element.
x = 10

As you see above, each controller must have at least one trigger. A 
trigger is an event that causes the controller to be activated. This 
example has two triggers, and the controller is activated when EITHER 
ONE is true.

III.d.2 Triggers
----------------
i. Trigger logic

The first trigger should always be "trigger1", and subsequent triggers 
should be "trigger2", then "trigger3" and so on. The logic for deciding 
if a controller should be activated is:
1. Are all conditions of "trigger1" true? If so, then yes, activate the 
controller.
2. Otherwise, repeat the test for "trigger2", and so on, until no more 
triggers are found.
This can be thought of as "OR" logic.

Be careful; skipping numbers will cause some triggers to be ignored. 
For example, if you have triggers "trigger1", "trigger2" and "trigger4" 
without a "trigger3", then "trigger4" will be ignored.

Now what if you want more than one condition to be met before the 
controller is activated? Here is an commonly-used example for testing 
if a player in the air has reached the ground. The triggers used are:
trigger1 = Vel Y > 0 ; True if Y-velocity is > 0 (going down)
trigger1 = Pos Y > 0 ; True if Y-position is > 0 (below ground)
At this point, you may be confused by the format of the trigger. Do not 
worry about it for now. We will get to it soon.
As you can see above, both the triggers have the same number. When 
several triggers have the same number, it implements the "AND" logic. 
That is, the controller is activated if every one of the triggers with 
the same number is true, but not if one or more of them is false.

You can combine both ideas. For example:
trigger1 = Vel Y > 0 ; True if Y-velocity is > 0 (going down)
trigger1 = Pos Y > 0 ; True if Y-position is > 0 (below ground)
trigger2 = Time = 5  ; True if state-time is 5
The controller for this would be activated if the player landed on the 
ground (Y-velocity and Y-Position are both > 0), OR if his state time 
was 5.

Here is a summary:
- Triggers with the same number activate the controller only if all of 
them are true.
- Triggers with different numbers activate the controller if any one or 
more of them are true.

The format of a trigger is:
trigger? = trigger_type trigger_test
trigger_type is the name of the trigger (see Appendix A for the full 
list). The trigger_test depends on the trigger_type, and is usually a 
simple mathematical test such as " = value". For example, in :
trigger1 = Time != 5
The trigger_type is "Time", and the trigger_test is " != 5".
In:
trigger1 = Vel Y > 0
The trigger_type is "Vel Y", and the trigger_test is " > 0".

The comparison symbols you can use are:
=      equal to
!=     not equal to
<      less than
>      greater than
<=     less than or equal to
>=     greater than or equal to

If you want to test to see if a value is in a certain range, you can 
use the range equality test. For example,
trigger1 = Time = [5,10]
This will be true if the state-time is between 5 and 10, inclusive. In 
other words, true if state-time >= 5 AND state-time <= 10.
The following:
trigger1 = Vel X = (2,5)
Is true if the X-velocity of the player is between 2 and 5, non-
inclusive. In other words, true if X-velocity > 2 AND X-velocity < 5.
You can mix the range test types, such as:
trigger1 = Pos Y = [-12, -2)
Remember that in range tests, the smaller value should be on the left.

A useful shortcut you might use is "triggerall". It determines a 
condition that must be true for all triggers. For instance in:

triggerall = Vel X = 0
trigger1 = Pos Y > -2
trigger2 = AnimElem = 3
trigger3 = Time = [2,9]

For any of trigger1 to trigger3 to be true, the triggerall condition 
must be true too. In this case, as long as the X-velocity is not 0, 
then the state controller will not be activated. You can have more than 
one triggerall condition if you need.

ii. Trigger persistency

In the case where you do not want the trigger to activate every single 
time the condition is true, you will need to add a "persistent" 
paramter. Let us begin with an example:

[State 310, 1]
type = PosAdd
trigger1 = Vel Y > 1
x = 10

This state controller moves P1 forwards by 10 pixels for every tick of 
game time where P1's Y-velocity is greater than 1. That is, the 
controller is being activated everytime the trigger condition is true. 
If we want the controller to be activated only once, we will need to 
add a line:

[State 310, 1]
type = PosAdd
trigger1 = Vel Y > 1
persistent = 0       ;<-- Added this line
x = 10

"Persistent" has a default value of 1, meaning that the controller is 
activated everytime the trigger is true.
Setting "persistent" to 0 allows the controller to be activated only 
once during that state. This holds true until P1 leaves that state. If 
P1 returns to that state later, the controller can be activated once 
again.

The "persistent" parameter can also take values other than 0 and 1:

[State 310, 1]
type = PosAdd
trigger1 = Vel Y > 1
persistent = 2       ;<-- Modified this line
x = 10

In this case, setting "persistent" to 2 means the controller will be 
activated once of every two times the trigger is true. Setting 
"persistent" to 3 activates the controller every 3rd time, and so on.

III.d.3 Commonly-used controllers
---------------------------------

The "Null" controller will be useful for debugging. A "null" controller 
basically does nothing. You can use it to temporarily turn off certain 
controllers, instead of commenting out the entire section. For example, 
you might want to disable this:

[State 300, 1] ;Controller that accelerates P1 forwards
type = VelAdd
trigger1 = Time >= 0
x = .8

Simply comment out the type and put in "null":

[State 300, 1] ;Controller that accelerates P1 forwards
type = null ;VelAdd
trigger1 = Time >= 0
x = .8

Later, when you want to reenable the controller, just change the type 
back to what it used to be.

Now let us look back at the example:

[Statedef 200]
type = S
physics = S
movetype = I
ctrl = 0
anim = 200
velset = 0

[State 200, 1]
type = ChangeState
trigger1 = AnimTime = 0
value = 0
ctrl = 1

[State 200, 1] is a "ChangeState" controller. As the name implies, it 
changes P1's state number. The "value" parameter should have the number 
of the state to change to. The optional "ctrl" parameter can be set 
P1's control flag as he changes states.

Now let's make this an attack state. First of all, the animation action 
needs attack collision boxes. A quick review from the air 
documentation: Clsn1 is for attack and Clsn2 is where the player can be 
hit. So P1 will hit P2 if any one of P1's Clsn1 boxes intersects with 
any of P2's Clsn2 boxes.

As an example, let's assume the animation action in P1's AIR file looks 
like this:

[Begin Action 200]
200,0, 0,0, 3
200,1, 0,0, 4
200,2, 0,0, 4
200,3, 0,0, 3

After defining the bounding boxes, it looks like:

[Begin Action 200]
Clsn2: 1
  Clsn2[0] = -10,0, 10,-80
200,0, 0,0, 3
Clsn1: 1
  Clsn1[0] =  10,-70, 40,-60
Clsn2: 2
  Clsn2[0] = -10,  0, 10,-80
  Clsn2[1] =  10,-70, 40,-60
200,1, 0,0, 4
Clsn2Default: 1 ;Use this box for the last two frames
  Clsn2[0] = -10,0, 10,-80
200,2, 0,0, 4
200,3, 0,0, 3

As you can see, each element has a Clsn2 box defined for it (the last 
two elements are using the same boxes). The second element is the only 
one with a Clsn1 box.

Note: It is all right to define Clsn1 boxes for any elements in an 
Animation Action, but if you put a Clsn1 box in the very first element, 
the attack will be instantaneous, and become unblockable. Therefore, it 
is recommended that you define Clsn1 boxes only for elements after the 
first one.

Now we are ready to set up the state in the CNS. We will explain the 
changes below.

[Statedef 200]
type = S
physics = S
movetype = A  ;<-- changed from "I" to "A"
ctrl = 0
anim = 200
velset = 0

[State 200, 1] ;<-- Added this state controller
type = HitDef
trigger1 = AnimElem = 2
attr = S, NA
animtype  = Light
damage    = 10
guardflag = MA
pausetime = 12,12
sparkxy = 0,-55
hitsound   = 5,0
guardsound = 6,0
ground.type = High
ground.slidetime = 12
ground.hittime  = 15
ground.velocity = -5
air.velocity = -2.5,-3.5

[State 200, 2]
type = ChangeState
trigger1 = AnimTime = 0
value = 0
ctrl = 1

The "movetype" parameter in the StateDef is set to "A" for "attack". 
Remember to do this for all attack states. As before, P1 changes back 
to his standing state after his animation is over.

That HitDef controller looks like a monster! Do not worry, we will go 
through it slowly.

L1: type = HitDef
L2: trigger1 = AnimElem = 2
This specifies the controller type as "HitDef", which stands for "Hit 
Definition". It is triggered on the second element of animation. Any 
Clsn2 box from the time the trigger was activated will take on this hit 
definition.
If, for example, you had a Clsn1 in both the second and third element 
of animation, triggering a single HitDef at the second element makes it 
apply to both elements of animation. So P1 will hit at most once: if 
the second element hits, the third will miss. If the second element 
misses, the third can still hit. To make the attack hit twice, you must 
trigger a HitDef for each of the two elements.

L3: attr = S, NA
This is the attribute of the attack. It is used to determine if the 
attack can hit P2. In this case, it is a Standing Normal Attack.
"attr" has the format:
attr = arg1, arg2
Where:
- arg1 is either "S", "C" or "A". Similar to "statetype" for the 
StateDef, this says whether the attack is a standing, crouching, or 
aerial attack.
- arg2 is a 2-character string. The first character is either "N" for 
"normal", "S" for "special", or "H" for "hyper" (or "super", as it is 
commonly known). The second character must be either "A" for "attack" 
(a normal hit attack), "T" for "throw", or "P" for projectile.

L4: animtype = Light
This refers to the type of animation that P2 will go into when hit by 
the attack. Choose from "light", "medium", "hard" or "back". The first 
three should be self-explanatory. "Back" is the animation where P2 is 
knocked off her feet.

L5: damage = 10
This is the damage that P2 takes when hit, and it does no damage if 
guarded. If we changed that line to "damage = 10, 1", then it will do 1 
point of damage if guarded.

L6: guardflag = MA
"Guardflag" determines how P2 may guard the attack. Here, it may be 
guarded high(standing), low (crouching) and in the air. The argument 
must be a string of characters that includes any of the following: "H" 
for "high", "L" for "low" or "A" for air. "M" (mid) is equivalent to 
saying "HL".

L7: pausetime = 12,12
This is the time that each player will pause on the hit. The first 
argument is the time to freeze P1, measured in game-ticks. The second 
is the time to make P2 shake before recoiling from the hit.

L8: sparkxy = 0,-55
This is where to make the hit/guard spark. The arguments must be in the 
form "x, y". x is relative to the front of P2. A negative x makes a 
spark deeper inside P2. y is relative to P1. A negative y makes a spark 
higher up.

L9: hitsound = 5,0
This is the sound to play on hit (from fight.snd). The included 
fight.snd lets you choose from 5,0 (light hit sound) through to 5,4 
(painful whack).

L10: guardsound = 6,0
This is the sound to play on guard (from fight.snd). Right now all we 
have is 6,0.

L11: ground.type = High
This is the kind of attack for ground attacks (it also defaults to air 
attacks if you do not have "air.type = ?"). In this case, it is a high 
attack. Choose from "High" for attacks that make P2's head snap 
backwards, "Low" for attacks that look like that hit in the stomach, 
"Trip" for low sweep attacks, or "None" to not do anything to P2. 
"High" and "Low" attacks are the same on P2 if the AnimType is "Back".

L12: ground.slidetime = 12
This is the time in game-ticks that P2 will slide back for after being 
hit (this time does not include the pausetime for P2). Applicable only 
to hits that keep P2 on the ground.

L13: ground.hittime = 15
Time that P2 stays in the hit state after being hit. Applicable only to 
hits that keep P2 on the ground.

L14: ground.velocity = -5
Initial X-velocity to give P2 after being hit, if P2 is in a standing 
or crouching state on the ground. You can specify a Y-velocity as the 
second argument if you want P2 to be knocked into the air, eg. 
"ground.velocity = -3, -2".

L15: air.velocity = -2.5,-3.5
Initial velocity to give P2 if P2 is hit in the air

There are more things that you can control in a HitDef. See Appendix B 
for details.


------------------------------
e. Common states (common1.cns)
------------------------------

If you look at a player's DEF file, you will see the line:
stcommon = common1.cns  ;Common states
Every player shares some common states, which are the basic parts of 
the game engine. These common states are found in data/common1.cns. 
Some examples are states for running and getting hit. A full list is 
available in Appendix C, Special State Controller Numbers.

If there is a common state that you would like to override for a 
certain player, all you need to do is make a state in that player's CNS 
with the same number as the one you would like to override. Then, when 
the player changes to that certain state number, he will enter that new 
state, instead of the one in common1.cns.

You should remember that when overriding certain states that have 
special properties coded inside M.U.G.E.N, the new states you make will 
still have the same special properties as the ones you overrode. For 
example, the run state (state 100) sets the player's velocity to 
whatever values you specified in his player variables. If you override 
state 100, the new state will still have the property of setting that 
player's velocity.

A common example is overriding the running state. M.U.G.E.N's default 
behaviour for the running state is to have the player continue moving 
forward at a constant speed, until you let go of the forward key. At 
that point he returns to the stand state.

Now, let's say we want that player (let us call him P1) to instead hop 
forward, just like the default double-tap back hop. You can make a 
state in P1's CNS:

; RUN_FWD (overridden to dash-type)
[Statedef 100]
type    = S   ;Running is on the ground
physics = N   ;We'll define our own physics
anim = 100    ;Anim action 100
ctrl = 0      ;No control for duration of dash

[State 100, 1] ;To start dashing forwards
type = VelSet
trigger1 = Time = [0,5]
x = 6

[State 100, 2] ;Friction after initial dash
type = VelMul
trigger1 = Time > 5
x = .85

[State 100, 3] ;
type = ChangeState
trigger1 = AnimTime = 0
value = 0
ctrl = 1

Here, we assume that Action 100 has a finite looptime. The velocity in 
"run.fwd" under [Velocity] of the player variables is not really 
ignored, but [State 100,1] overrides that detail by setting the X-
velocity to 6.



============================================================
Appendix A.  State Trigger Index
============================================================

Commonly-used
-------------
-Time
-AnimTime
-AnimElem
-Pos, Vel
-P2Dist, P2BodyDist
-Command
-StateNo, StateType
-MoveContact, MoveHit, MoveGuard

Others
------
-


------------------------------------------------------------
Time
------------------------------------------------------------

Gives the state-time of the player.

Format:
  Time (oper) value

Arguments:
  (oper)
    =, !=, <, >, <=, >=
  value (int)
    Value to compare with.

Example:
  trigger1 = Time = 2
    Triggers when the player's state-time is 2.


------------------------------------------------------------
AnimTime
------------------------------------------------------------

Gives the difference between the looptime of the current animation 
action and the player's animation-time. Useful for knowing when the end 
of the animation has been reached. 
(animation-time is the time in game-ticks that the player has spent 
within the current animation action)

Format:
  AnimTime = value

Arguments:
  (oper)
    =, !=, <, >, <=, >=
  value (int)
    Value to compare with. Should be 0 or less.

Example:
  trigger1 = AnimTime = 0
    Triggers when the animation-time is equal to the animation
    action's looptime, ie. the end of the action has been
    reached.


------------------------------------------------------------
AnimElem
------------------------------------------------------------

Gets the animation-time elapsed since the start of a specified element 
of the current animation action. Useful for synchronizing events to 
elements of an animation action.
(reminder: first element of an action is element 1, not 0)

Format:
  1.  trigger1 = AnimElem = value1
  2.  trigger1 = AnimElem = value1, (oper) value2

Arguments:
  (oper)
    =, !=, <, >, <=, >=
  value1 (int)
    Element number to check.
  value2 (int)
    Value of animation-time to compare with.

Details:
  Trigger in Format 1 is true if the player's animation is
  at the start of the element number specified by value1.
  In other words, if value1 is equal to n, it is true on the
  first game-tick of the nth element of the animation.
  Trigger in Format 2 compares the player's animation-time
  to t+value2, where t is time of the start of the element
  number specified by value1.
  If value1 is an invalid animation element, M.U.G.E.N may
  crash or behave strangely.  

Examples:
  trigger1 = AnimElem = 2
    True on the first game-tick that the player's animation
    is on element 2. Is equivalent to saying:
      trigger1 = AnimElem = 2, = 0

  trigger1 = AnimElem = 2, = 4
    True 4 game-ticks after the start of the player's
    second animation element.

  trigger1 = AnimElem = 2, >= 0
  trigger1 = AnimElem = 3, < 0
    True for the whole of the second element of the player's
    animation, assuming there is a third element. If a
    third element does not exist, the second line should
    read,
      trigger1 = AnimTime <= 0


------------------------------------------------------------
Pos, Vel
------------------------------------------------------------

Gets the value of the player's position or velocity. You
must specify the component that you want to check, eg.
"Pos Y" to check the Y-position.

Format:
  1.  trigger1 = Pos (component) (oper) valuef1
  2.  trigger1 = Vel (component) (oper) valuef1

Arguments:
  (component)
    X, Y
  (oper)
    =, !=, <, >, <=, >=
  valuef1 (decimal)
    The value to compare with.

Details:
  For "Pos X", the value is relative to the center of the
  stage (value 0). Negative is left, positive is right.
  For "Pos Y", the value is relative to the floor. Negative
  is higher up, positive is below the floor.

Example:
  trigger1 = Pos Y >= 0
    True when the player is below the floor.

  trigger1 = Vel X > 0.5
    True when the player's X-velocity greater than 0.5.


------------------------------------------------------------
P2Dist, P2BodyDist
------------------------------------------------------------

Gives the distance of P2 from P1, where P1 is the player, and P2 is his 
opponent. P2BodyDist is useful in the CMD for cases where P1 has an 
attack that is different when performed close to P2.

Format:
  1. trigger1 = P2Dist (component) (oper) valuef1
  2. trigger1 = P2BodyDist (component) (oper) valuef1

Arguments:
  (component)
    X, Y
  (oper)
    =, !=, <, >, <=, >=
  valuef1 (decimal)
    The value to compare with.

Details:
  For comparing the Y-distance, P2Dist and P2BodyDist work
  exactly the same. The value is negative if P2 is above P1.
  For comparing the X-distance, P2Dist gives the X-distance
  of P2's axis from P1's axis. A positive value indicates P2
  is in front of P1.
  For comparing the X-distance, P2BodyDist gives the
  X-distance of P2's front from P1's front. So, if the
  players are standing right next to each other, then
  P2BodyDist is 0. Remember that you can set the width of
  the player in "front.width", etc. under [Size] in the
  player variables.

Example:
  trigger1 = P2Dist Y <= -12
    True if P2 is at least -12 pixels higher up than P1.


------------------------------------------------------------
Command
------------------------------------------------------------

Triggers if the user has input the specified command.

Format:
  trigger1 = Command (oper) command_name

Arguments:
  (oper)
    =, !=   (other operators not valid)
  command_name (string)
    Name of the command. Commands are defined in the
    player's CMD file, and are case-sensitive.

Example:
  trigger1 = fireball_motion
    True if the user inputs the command corresponding to the
    command name "fireball_motion".


------------------------------------------------------------
StateNo, StateType
------------------------------------------------------------

StateNo gives the player's state number, while StateType gives the 
player's state-type. Useful for "move interrupts" in the CMD file.

Format:
  1. trigger1 = StateNo (oper1) value1
  2. trigger1 = StateType (oper2) state_type

Arguments:
  (oper1)
    =, !=, <, >, <=, >=
  value1 (int)
    Numerical value to compare with.
  (oper2)
    =, !=   (other operators not valid)
  state_type (char)
    S, C, A
    Stand, Crouch and Air state-types.

Example:
  trigger1 = StateNo = 200
    True if the player is in state number 200.

  trigger1 = StateType = S
    True if the player is in a stand-type state.


------------------------------------------------------------
MoveContact, MoveHit, MoveGuard
------------------------------------------------------------

These triggers are valid only when the player is in an attack state.
MoveContact gives 1 if P2 has either been hit, or has guarded P1's 
attack. It gives 0 otherwise. P1 is the player, and P2 is his opponent.
MoveHit gives 1 if P2 has either been hit, or has guarded P1's attack. 
It gives 0 if the attack missed or was guarded.
MoveGuard gives 1 if P2 has guarded, or has guarded P1's attack. It 
gives 0 if the attack missed or successfully hit.
Typically used with the "StateNo" and "Command" triggers for detecting 
move-interrupts in the CMD file.

Format:

Arguments:
  (oper)
    =, !=, <, >, <=, >=
  value1 (int)
    Either 0 or 1.


Example:
  trigger1 = MoveContact = 1
    True if P1's attack did not miss P2.


------------------------------------------------------------

------------------------------------------------------------



Format:

Arguments:
  (oper)
    =, !=, <, >, <=, >=


Example:
  trigger1 =





============================================================
Appendix B.  State Controller Index
============================================================

Commonly-used
-------------
-ChangeState
-ChangeAnim
-PosSet, VelSet, PosAdd, VelAdd, VelMul
-Gravity
-PlaySnd
-HitDef
-HitBy, NotHitBy
-LifeSet, LifeAdd, PowerSet, PowerAdd

Effects
-------
-MakeDust
-GameMakeAnim
-EnvShake
-EnvColor

Others
------
-


============================================================
Appendix C.  Special State Controller Numbers
============================================================

Number      Description
------      -----------
0           Stand
10          Stand-to-crouch
11          Crouching
12          Crouch-to-stand
20          Walk

To be finished.



